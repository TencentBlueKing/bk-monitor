diff --git a/bkmonitor/metadata/migrations/0245_auto_20251121_1510.py b/bkmonitor/metadata/migrations/0245_auto_20251121_1510.py
new file mode 100644
index 0000000000..724d508db5
--- /dev/null
+++ b/bkmonitor/metadata/migrations/0245_auto_20251121_1510.py
@@ -0,0 +1,50 @@
+# Generated by Django 3.2.25 on 2025-11-21 07:10
+
+from django.db import migrations, models
+
+import bkmonitor.utils.db.fields
+
+
+class Migration(migrations.Migration):
+    dependencies = [
+        ("metadata", "0244_customrelationstatus"),
+    ]
+
+    operations = [
+        migrations.AddField(
+            model_name="clusterinfo",
+            name="display_name",
+            field=models.CharField(blank=True, default="", max_length=128, verbose_name="集群显示名称"),
+        ),
+        migrations.AlterField(
+            model_name="clusterinfo",
+            name="cluster_name",
+            field=models.CharField(max_length=128, verbose_name="集群英文名"),
+        ),
+        migrations.AddField(
+            model_name="clusterinfo",
+            name="registered_to_bkbase",
+            field=models.BooleanField(default=False, verbose_name="是否已经注册到bkbase平台"),
+        ),
+        migrations.CreateModel(
+            name="ClusterConfig",
+            fields=[
+                ("id", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
+                ("bk_tenant_id", models.CharField(max_length=255, verbose_name="租户ID")),
+                ("namespace", models.CharField(max_length=255, verbose_name="命名空间")),
+                ("name", models.CharField(max_length=255, verbose_name="集群名称")),
+                ("kind", models.CharField(max_length=255, verbose_name="集群类型")),
+                (
+                    "origin_config",
+                    bkmonitor.utils.db.fields.SymmetricJsonField(default=dict, verbose_name="原始配置"),
+                ),
+                ("create_time", models.DateTimeField(auto_now_add=True, verbose_name="创建时间")),
+                ("update_time", models.DateTimeField(auto_now=True, verbose_name="最后更新时间")),
+            ],
+            options={
+                "verbose_name": "集群配置",
+                "verbose_name_plural": "集群配置",
+                "unique_together": {("bk_tenant_id", "namespace", "kind", "name")},
+            },
+        ),
+    ]
diff --git a/bkmonitor/metadata/migrations/0246_migrate_cluster_name.py b/bkmonitor/metadata/migrations/0246_migrate_cluster_name.py
new file mode 100644
index 0000000000..8c068faec8
--- /dev/null
+++ b/bkmonitor/metadata/migrations/0246_migrate_cluster_name.py
@@ -0,0 +1,32 @@
+import re
+from django.db import migrations
+
+
+def migrate_cluster_name(apps, schema_editor):
+    ClusterInfo = apps.get_model("metadata", "ClusterInfo")
+
+    re_cluster_name = re.compile(r"^[_A-Za-z0-9][_A-Za-z0-9-]{0,49}$")
+    for cluster in ClusterInfo.objects.all():
+        # 设置显示名称
+        cluster.display_name = cluster.cluster_name
+
+        # 检查cluster_name是否符合[a-zA-Z][a-zA-Z0-9_]*格式
+        if not re_cluster_name.match(cluster.cluster_name):
+            # 替换为新的cluster_name，体现自动生成的含义
+            cluster.cluster_name = f"auto_cluster_name_{cluster.cluster_id}"
+
+        # 如果集群类型为VM或注册来源系统为BKDATA，则默认标记为已注册到bkbase平台
+        if cluster.cluster_type == "victoria_metrics" or cluster.registered_system == "bkdata":
+            cluster.registered_to_bkbase = True
+
+        cluster.save()
+
+
+class Migration(migrations.Migration):
+    dependencies = [
+        ("metadata", "0245_auto_20251121_1510"),
+    ]
+
+    operations = [
+        migrations.RunPython(migrate_cluster_name),
+    ]
diff --git a/bkmonitor/metadata/models/data_link/data_link.py b/bkmonitor/metadata/models/data_link/data_link.py
index 93289aaf87..c6e52fd34a 100644
--- a/bkmonitor/metadata/models/data_link/data_link.py
+++ b/bkmonitor/metadata/models/data_link/data_link.py
@@ -877,6 +877,9 @@ def compose_bcs_federal_subset_time_series_configs(
 
         config_list, conditions = [], []
         for record in federal_records:
+            if not record.fed_builtin_metric_table_id:
+                continue
+
             # 联邦代理集群的RT名
             proxy_k8s_metric_vmrt_name = utils.compose_bkdata_table_id(record.fed_builtin_metric_table_id)
             relabels = [{"name": "bcs_cluster_id", "value": record.fed_cluster_id}]
@@ -1112,7 +1115,7 @@ def apply_data_link(self, *args, **kwargs):
         except RetryError as e:
             logger.error("apply_data_link: data_link_name->[%s] retry error->[%s]", self.data_link_name, e.__cause__)
             # 抛出底层错误原因，而非直接RetryError
-            raise e.__cause__
+            raise e.__cause__ if e.__cause__ else e
         except Exception as e:  # pylint: disable=broad-except
             logger.error("apply_data_link: data_link_name->[%s] apply error->[%s]", self.data_link_name, e)
             raise e
diff --git a/bkmonitor/metadata/models/data_link/data_link_configs.py b/bkmonitor/metadata/models/data_link/data_link_configs.py
index 37d3a27a14..fb5eeb93ce 100644
--- a/bkmonitor/metadata/models/data_link/data_link_configs.py
+++ b/bkmonitor/metadata/models/data_link/data_link_configs.py
@@ -16,16 +16,18 @@
 from django.db import models
 from typing_extensions import deprecated
 
+from bkmonitor.utils.db.fields import SymmetricJsonField
 from bkmonitor.utils.tenant import get_tenant_datalink_biz_id
 from core.drf_resource import api
 from metadata.models.data_link import constants, utils
-from metadata.models.data_link.constants import DataLinkKind
+from metadata.models.data_link.constants import BKBASE_NAMESPACE_BK_LOG, BKBASE_NAMESPACE_BK_MONITOR, DataLinkKind
 from metadata.models.space.constants import LOG_EVENT_ETL_CONFIGS
 
 logger = logging.getLogger("metadata")
 
 if TYPE_CHECKING:
     from metadata.models.data_source import DataSource
+    from metadata.models.storage import ClusterInfo
 
 
 class DataLinkResourceConfigBase(models.Model):
@@ -822,6 +824,148 @@ def compose_config(
         )
 
 
+class ClusterConfig(models.Model):
+    """
+    集群信息配置
+    """
+
+    # 由于配置原因，namespace实际上与存储类型是绑定的，与实际的使用方无关
+    KIND_TO_NAMESPACE_MAP = {
+        DataLinkKind.ELASTICSEARCH.value: BKBASE_NAMESPACE_BK_LOG,
+        DataLinkKind.VMSTORAGE.value: BKBASE_NAMESPACE_BK_MONITOR,
+        DataLinkKind.DORIS.value: BKBASE_NAMESPACE_BK_LOG,
+    }
+
+    CLUSTER_TYPE_TO_KIND_MAP = {
+        "elasticsearch": DataLinkKind.ELASTICSEARCH.value,
+        "victoria_metrics": DataLinkKind.VMSTORAGE.value,
+        "doris": DataLinkKind.DORIS.value,
+    }
+
+    bk_tenant_id = models.CharField(max_length=255, verbose_name="租户ID")
+    namespace = models.CharField(max_length=255, verbose_name="命名空间")
+    name = models.CharField(max_length=255, verbose_name="集群名称")
+    kind = models.CharField(max_length=255, verbose_name="集群类型")
+    origin_config = SymmetricJsonField(verbose_name="原始配置", default=dict)
+    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
+    update_time = models.DateTimeField(auto_now=True, verbose_name="最后更新时间")
+
+    class Meta:
+        verbose_name = "集群配置"
+        verbose_name_plural = verbose_name
+        unique_together = (("bk_tenant_id", "namespace", "kind", "name"),)
+
+    @property
+    def component_config(self):
+        """
+        组件完整配置（bkbase侧）
+        """
+        from metadata.models.data_link.service import get_data_link_component_config
+
+        return get_data_link_component_config(
+            bk_tenant_id=self.bk_tenant_id,
+            kind=self.kind,
+            namespace=self.namespace,
+            component_name=self.name,
+        )
+
+    def get_cluster(self) -> "ClusterInfo":
+        """获取集群信息"""
+        from metadata.models.storage import ClusterInfo
+
+        # 将 kind 映射回 cluster_type，需反向映射 CLUSTER_TYPE_TO_KIND_MAP
+        kind_to_cluster_type: dict[str, str] = {v: k for k, v in self.CLUSTER_TYPE_TO_KIND_MAP.items()}
+        cluster_type: str | None = kind_to_cluster_type.get(self.kind)
+        if not cluster_type:
+            raise ValueError(f"不支持的集群类型: {self.kind}")
+        return ClusterInfo.objects.get(
+            bk_tenant_id=self.bk_tenant_id,
+            cluster_type=cluster_type,
+            cluster_name=self.name,
+        )
+
+    def compose_config(self) -> dict[str, Any]:
+        """
+        组装集群配置
+        """
+        cluster = self.get_cluster()
+
+        if self.kind == DataLinkKind.ELASTICSEARCH.value:
+            return self.compose_es_config(cluster)
+        else:
+            raise ValueError(f"不支持的集群类型: {self.kind}")
+
+    def compose_es_config(self, cluster: "ClusterInfo") -> dict[str, Any]:
+        """组装ES集群配置
+
+        Args:
+            cluster: 集群信息
+
+        Returns:
+            dict[str, Any]: 集群配置
+        """
+
+        config = {
+            "kind": "ElasticSearch",
+            "metadata": {
+                "tenant": cluster.bk_tenant_id if settings.ENABLE_MULTI_TENANT_MODE else "default",
+                "namespace": BKBASE_NAMESPACE_BK_LOG,
+                "name": cluster.cluster_name,
+            },
+            "spec": {
+                "host": cluster.domain_name,
+                "port": cluster.port,
+                "user": cluster.username,
+                "password": cluster.password,
+            },
+        }
+
+        return config
+
+    @classmethod
+    def sync_cluster_config(cls, cluster: "ClusterInfo") -> None:
+        """
+        同步集群配置
+
+        Note:
+            将集群信息同步到bkbase平台，并更新集群注册状态
+            如果集群类型不在支持的类型中，则不需要进行同步
+
+        Args:
+            cluster: 集群信息
+        """
+        from metadata.models.storage import ClusterInfo
+
+        # NOTE: 目前仅允许将ES集群配置到bkbase平台，VM和Doris集群需要通过bkbase配置，定时任务会自动从bkbase拉取配置
+        if cluster.cluster_type not in [ClusterInfo.TYPE_ES]:
+            return
+
+        # 根据集群类型获取kind和namespace
+        kind = cls.CLUSTER_TYPE_TO_KIND_MAP[cluster.cluster_type]
+        namespace = cls.KIND_TO_NAMESPACE_MAP[kind]
+
+        # 获取或创建bkbase集群配置记录
+        cluster_config, _ = ClusterConfig.objects.get_or_create(
+            bk_tenant_id=cluster.bk_tenant_id, namespace=namespace, name=cluster.cluster_name, kind=kind
+        )
+
+        # 组装配置
+        config = cluster_config.compose_config()
+
+        # 注册到bkbase平台
+        try:
+            api.bkdata.apply_data_link(config=[config], bk_tenant_id=cluster.bk_tenant_id)
+        except Exception as e:
+            logger.error(f"sync_cluster_config: apply data link error: {e}")
+            raise e
+
+        # 更新集群注册状态
+        cluster_config.origin_config = config
+        cluster_config.save()
+        cluster.registered_to_bkbase = True
+        cluster.save()
+
+
 @deprecated("已废弃，统一使用DataBusConfig替代")
 class LogDataBusConfig(DataLinkResourceConfigBase):
     """
diff --git a/bkmonitor/metadata/models/storage.py b/bkmonitor/metadata/models/storage.py
index b5e6cbf669..baf32e30ec 100644
--- a/bkmonitor/metadata/models/storage.py
+++ b/bkmonitor/metadata/models/storage.py
@@ -16,7 +16,7 @@
 import re
 import time
 import traceback
-from typing import Any
+from typing import TYPE_CHECKING, Any
 
 import arrow
 import curator
@@ -79,10 +79,14 @@
 
 logger = logging.getLogger("metadata")
 
-ResultTableField = None
-ResultTableFieldOption = None
-ResultTable = None
-EventGroup = None
+
+if TYPE_CHECKING:
+    from metadata.models.custom_report import EventGroup
+    from metadata.models.result_table import ResultTable, ResultTableField
+else:
+    ResultTableField = None
+    ResultTable = None
+    EventGroup = None
 
 
 class ClusterInfo(models.Model):
@@ -92,6 +96,9 @@ class ClusterInfo(models.Model):
     如果需要看到influxDB-proxy后面的实际集群信息，请看InfluxDBClusterInfo记录
     """
 
+    # 集群英文名正则表达式，要求符合 [_A-Za-z0-9][_A-Za-z0-9-]* 格式，且长度不超过50，与bkbase的集群名命名规则一致
+    CLUSTER_NAME_REGEX = re.compile(r"^[_A-Za-z0-9][_A-Za-z0-9-]{0,49}$")
+
     CONSUL_PREFIX_PATH = f"{config.CONSUL_PATH}/unify-query/data/storage"
     CONSUL_VERSION_PATH = f"{config.CONSUL_PATH}/unify-query/version/storage"
 
@@ -122,8 +129,8 @@ class ClusterInfo(models.Model):
 
     bk_tenant_id = models.CharField("租户ID", max_length=64, default=DEFAULT_TENANT_ID)
     cluster_id = models.AutoField("集群ID", primary_key=True)
-    # 集群中文名，便于管理员维护
-    cluster_name = models.CharField("集群名称", max_length=128)
+    cluster_name = models.CharField("集群英文名", max_length=128)
+    display_name = models.CharField("集群显示名称", max_length=128, default="", blank=True)
     cluster_type = models.CharField("集群类型", max_length=32, db_index=True)
     domain_name = models.CharField("集群域名", max_length=128)
     port = models.IntegerField("端口")
@@ -156,6 +163,7 @@ class ClusterInfo(models.Model):
 
     # 描述该存储集群被何系统使用
     registered_system = models.CharField("注册来源系统", default=DEFAULT_REGISTERED_SYSTEM, max_length=128)
+    registered_to_bkbase = models.BooleanField("是否已经注册到bkbase平台", default=False)
 
     # GSE注册相关
     # 是否需要往GSE注册
@@ -237,7 +245,7 @@ def refresh_consul_storage_config(cls):
 
         logger.info(f"all es table info is refresh to consul success count->[{total_count}].")
 
-    def base64_with_prefix(self, content: str) -> str:
+    def base64_with_prefix(self, content: str | None) -> str | None:
         """编码，并添加上前缀"""
         # 如果为空，则直接返回
         if not content:
@@ -357,6 +365,7 @@ def create_cluster(
         port,
         registered_system,
         operator,
+        display_name="",
         description="",
         username="",
         password="",
@@ -400,6 +409,11 @@ def create_cluster(
         :param extranet_port: 外网端口
         :return: clusterInfo object
         """
+        from metadata.models.data_link.data_link_configs import ClusterConfig
+
+        # 如果未提供显示名称，则使用集群名作为显示名称
+        if not display_name:
+            display_name = cluster_name
 
         # 1. 判断请求的数据是否有冲突
         # 基本数据校验
@@ -430,6 +444,7 @@ def create_cluster(
         new_cluster = cls.objects.create(
             bk_tenant_id=bk_tenant_id,
             cluster_name=cluster_name,
+            display_name=display_name,
             cluster_type=cluster_type,
             domain_name=domain_name,
             port=port,
@@ -460,12 +475,16 @@ def create_cluster(
         )
         new_cluster.cluster_init()
 
+        # 同步集群配置到bkbase
+        ClusterConfig.sync_cluster_config(cluster=new_cluster)
+
         return new_cluster
 
     @atomic(config.DATABASE_CONNECTION_NAME)
     def modify(
         self,
         operator,
+        display_name=None,
         description=None,
         username=None,
         password=None,
@@ -486,6 +505,7 @@ def modify(
         """
         修改存储集群信息
         :param operator: 操作者
+        :param display_name: 显示名称
         :param description: 描述信息
         :param username: 用户名
         :param password: 密码
@@ -503,7 +523,11 @@ def modify(
         :param extranet_port: 外网端口
         :return: True | raise Exception
         """
+
+        from metadata.models.data_link.data_link_configs import ClusterConfig
+
         args = {
+            "display_name": display_name,
             "description": description,
             "username": username,
             "password": password,
@@ -534,6 +558,10 @@ def modify(
 
         self.save()
         logger.info(f"cluster->[{self.cluster_name}] update success.")
+
+        # 同步集群配置到bkbase
+        ClusterConfig.sync_cluster_config(cluster=self)
+
         return True
 
     @atomic(config.DATABASE_CONNECTION_NAME)
@@ -556,12 +584,14 @@ def delete(self, *args, **kwargs):
             )
             raise ValueError(_("存在未关闭的结果表 {}").format(",".join(enable_rts)))
 
-        super().delete(*args, **kwargs)
+        result = super().delete(*args, **kwargs)
 
         logger.info(
             f"cluster->[{self.cluster_name}] cluster_type->[{self.cluster_type}] has deleted by [{self.registered_system}]"
         )
 
+        return result
+
 
 class KafkaTopicInfo(models.Model):
     """数据源对应的Kafka队列配置"""
@@ -620,7 +650,6 @@ def create_info(cls, bk_data_id, topic=None, partition=1, batch_size=None, flush
 class StorageResultTable:
     """实际结果表基类，提供公共方法的模板"""
 
-    bk_tenant_id: str
     STORAGE_TYPE = None
     UPGRADE_FIELD_CONFIG = ()
 
diff --git a/bkmonitor/metadata/resources/cluster.py b/bkmonitor/metadata/resources/cluster.py
index a0a2dcadc1..2796e29e9e 100644
--- a/bkmonitor/metadata/resources/cluster.py
+++ b/bkmonitor/metadata/resources/cluster.py
@@ -8,14 +8,19 @@
 specific language governing permissions and limitations under the License.
 """
 
+import base64
+import json
 from collections import OrderedDict
 from typing import Any
 
+from django.utils.translation import gettext_lazy as _
 from rest_framework import serializers
 from rest_framework.exceptions import ValidationError
 
+from bkmonitor.utils.request import get_app_code_by_request, get_request
 from bkmonitor.utils.serializers import TenantIdField
 from core.drf_resource import Resource
+from metadata import models
 from metadata.models.storage import ClusterInfo
 from metadata.service.storage_details import StorageClusterDetail
 
@@ -74,6 +79,7 @@ class RequestSerializer(serializers.Serializer):
         bk_tenant_id = TenantIdField(label="租户ID")
         cluster_name = serializers.CharField(label="集群名称")
         cluster_type = serializers.CharField(label="集群类型")
+        display_name = serializers.CharField(label="集群显示名称", required=False)
         domain = serializers.CharField(label="集群域名")
         port = serializers.IntegerField(label="集群端口")
         registered_system = serializers.CharField(label="注册来源系统")
@@ -118,3 +124,204 @@ def perform_request(self, validated_request_data: OrderedDict):
             raise ValidationError("cluster_id: %s not found", cluster_id)
 
         return cluster.modify(**validated_request_data)
+
+
+class CreateClusterInfoResource(Resource):
+    """创建存储集群资源"""
+
+    class RequestSerializer(serializers.Serializer):
+        bk_tenant_id = TenantIdField(label="租户ID")
+        cluster_name = serializers.RegexField(
+            required=True, label="集群名", regex=models.ClusterInfo.CLUSTER_NAME_REGEX
+        )
+        display_name = serializers.CharField(required=False, max_length=128, label="集群显示名称")
+        cluster_type = serializers.CharField(required=True, label="集群类型")
+        domain_name = serializers.CharField(required=True, label="集群域名")
+        port = serializers.IntegerField(required=True, label="集群端口")
+        description = serializers.CharField(required=False, label="集群描述数据", default="", allow_blank=True)
+        auth_info = serializers.JSONField(required=False, label="身份认证信息", default={})
+        version = serializers.CharField(required=False, label="版本信息", default="")
+        custom_option = serializers.CharField(required=False, label="自定义标签", default="")
+        schema = serializers.CharField(required=False, label="链接协议", default="")
+        is_ssl_verify = serializers.BooleanField(required=False, label="是否需要SSL验证", default=False)
+        ssl_verification_mode = serializers.CharField(required=False, label="校验模式", default="")
+        ssl_certificate_authorities = serializers.CharField(required=False, label="CA 证书内容", default="")
+        ssl_certificate = serializers.CharField(required=False, label="SSL/TLS 证书内容", default="")
+        ssl_certificate_key = serializers.CharField(required=False, label="SSL/TLS 私钥内容", default="")
+        ssl_insecure_skip_verify = serializers.BooleanField(required=False, label="是否跳过服务端校验", default=False)
+        extranet_domain_name = serializers.CharField(required=False, label="外网集群域名", default="")
+        extranet_port = serializers.IntegerField(required=False, label="外网集群端口", default=0)
+        operator = serializers.CharField(required=True, label="操作者")
+
+        def validate(self, attrs: dict[str, Any]):
+            # 如果未提供显示名称，则使用集群名作为显示名称
+            if not attrs.get("display_name"):
+                attrs["display_name"] = attrs["cluster_name"]
+            return super().validate(attrs)
+
+    def perform_request(self, validated_request_data):
+        # 获取请求来源系统
+        request = get_request()
+        bk_app_code = get_app_code_by_request(request)
+        validated_request_data["registered_system"] = bk_app_code
+
+        # 获取配置的用户名和密码
+        auth_info = validated_request_data.pop("auth_info", {})
+        # NOTE: 因为模型中字段没有设置允许为 null，所以不能赋值 None
+        validated_request_data["username"] = auth_info.get("username", "")
+        validated_request_data["password"] = auth_info.get("password", "")
+
+        cluster = models.ClusterInfo.create_cluster(**validated_request_data)
+        return cluster.cluster_id
+
+
+class ModifyClusterInfoResource(Resource):
+    """修改存储集群信息"""
+
+    class RequestSerializer(serializers.Serializer):
+        bk_tenant_id = TenantIdField(label="租户ID")
+        cluster_id = serializers.IntegerField(required=False, label="存储集群ID", default=None)
+        cluster_name = serializers.CharField(required=False, label="存储集群名", default=None)
+        cluster_type = serializers.CharField(required=False, label="存储集群类型", default=None)
+        display_name = serializers.CharField(required=False, max_length=128, label="集群显示名称", default=None)
+        description = serializers.CharField(required=False, label="存储集群描述", default=None, allow_blank=True)
+        auth_info = serializers.JSONField(required=False, label="身份认证信息", default={})
+        custom_option = serializers.CharField(required=False, label="集群自定义标签", default=None)
+        schema = serializers.CharField(required=False, label="集群链接协议", default=None)
+        is_ssl_verify = serializers.BooleanField(required=False, label="是否需要强制SSL/TLS认证", default=None)
+        ssl_verification_mode = serializers.CharField(required=False, label="校验模式", default=None)
+        ssl_certificate_authorities = serializers.CharField(required=False, label="CA 证书内容", default=None)
+        ssl_certificate = serializers.CharField(required=False, label="SSL/TLS 证书内容", default=None)
+        ssl_certificate_key = serializers.CharField(required=False, label="SSL/TLS 私钥内容", default=None)
+        ssl_insecure_skip_verify = serializers.BooleanField(required=False, label="是否跳过服务端校验", default=None)
+        extranet_domain_name = serializers.CharField(required=False, label="外网集群域名", default=None)
+        extranet_port = serializers.IntegerField(required=False, label="外网集群端口", default=None)
+        operator = serializers.CharField(required=True, label="操作者")
+
+    def perform_request(self, validated_request_data):
+        request = get_request()
+        bk_app_code = get_app_code_by_request(request)
+        bk_tenant_id = validated_request_data.pop("bk_tenant_id")
+
+        # 1. 判断是否存在cluster_id或者cluster_name
+        cluster_id: int = validated_request_data.pop("cluster_id")
+        cluster_name: str = validated_request_data.pop("cluster_name")
+
+        if cluster_id is None and cluster_name is None:
+            raise ValueError(_("需要至少提供集群ID或集群名"))
+
+        # 2. 判断是否可以拿到一个唯一的cluster_info
+        query_dict = {}
+        if cluster_id is not None:
+            query_dict["cluster_id"] = cluster_id
+        else:
+            query_dict["cluster_name"] = cluster_name
+            # 为了向前兼容，这里并不要求提供集群类型
+            if validated_request_data.get("cluster_type") is not None:
+                query_dict["cluster_type"] = validated_request_data["cluster_type"]
+
+        try:
+            cluster_info = models.ClusterInfo.objects.get(
+                bk_tenant_id=bk_tenant_id,
+                registered_system__in=[bk_app_code, models.ClusterInfo.DEFAULT_REGISTERED_SYSTEM],
+                **query_dict,
+            )
+        except models.ClusterInfo.DoesNotExist:
+            raise ValueError(_("找不到指定的集群配置，请确认后重试"))
+        except models.ClusterInfo.MultipleObjectsReturned:
+            raise ValueError(_("找到多个符合条件的集群配置，可能是不同类型的集群名相同，请提供集群类型后重试"))
+
+        # 3. 判断获取是否需要修改用户名和密码
+        auth_info = validated_request_data.pop("auth_info", {})
+        # NOTE: 因为模型中字段没有设置允许为 null，所以不能赋值 None
+        validated_request_data["username"] = auth_info.get("username", "")
+        validated_request_data["password"] = auth_info.get("password", "")
+
+        # 4. 触发修改内容
+        cluster_info.modify(**validated_request_data)
+        return cluster_info.consul_config
+
+
+class DeleteClusterInfoResource(Resource):
+    """删除存储集群信息"""
+
+    class RequestSerializer(serializers.Serializer):
+        bk_tenant_id = TenantIdField(label="租户ID")
+        cluster_id = serializers.IntegerField(required=False, label="存储集群ID", default=None)
+        cluster_name = serializers.CharField(required=False, label="存储集群名", default=None)
+
+    def perform_request(self, validated_request_data):
+        request = get_request()
+        bk_app_code = get_app_code_by_request(request)
+
+        #  判断是否存在cluster_id或者cluster_name
+        cluster_id = validated_request_data.pop("cluster_id")
+        cluster_name = validated_request_data.pop("cluster_name")
+
+        if cluster_id is None and cluster_name is None:
+            raise ValueError(_("需要至少提供集群ID或集群名"))
+
+        #  判断是否可以拿到一个唯一的cluster_info
+        query_dict = {"cluster_id": cluster_id} if cluster_id is not None else {"cluster_name": cluster_name}
+        try:
+            cluster_info = models.ClusterInfo.objects.get(
+                bk_tenant_id=validated_request_data["bk_tenant_id"], registered_system=bk_app_code, **query_dict
+            )
+        except models.ClusterInfo.DoesNotExist:
+            raise ValueError(_("找不到指定的集群配置，请确认后重试"))
+
+        cluster_info.delete()
+
+
+class QueryClusterInfoResource(Resource):
+    class RequestSerializer(serializers.Serializer):
+        bk_tenant_id = TenantIdField(label="租户ID")
+        cluster_id = serializers.IntegerField(required=False, label="存储集群ID", default=None)
+        cluster_name = serializers.CharField(required=False, label="存储集群名", default=None)
+        cluster_type = serializers.CharField(required=False, label="存储集群类型", default=None)
+        is_plain_text = serializers.BooleanField(required=False, label="是否需要明文显示登陆信息", default=False)
+
+    def perform_request(self, validated_request_data):
+        query_dict = {}
+        if validated_request_data["cluster_id"] is not None:
+            query_dict = {"cluster_id": validated_request_data["cluster_id"]}
+
+        elif validated_request_data["cluster_name"] is not None:
+            query_dict = {"cluster_name": validated_request_data["cluster_name"]}
+
+        if validated_request_data["cluster_type"] is not None:
+            query_dict["cluster_type"] = validated_request_data["cluster_type"]
+
+        query_result = models.ClusterInfo.objects.filter(
+            bk_tenant_id=validated_request_data["bk_tenant_id"], **query_dict
+        )
+
+        result_list = []
+        is_plain_text = validated_request_data["is_plain_text"]
+
+        for cluster_info in query_result:
+            cluster_consul_config = cluster_info.consul_config
+
+            # 如果不是明文的方式，需要进行base64编码
+            if not is_plain_text:
+                cluster_consul_config["auth_info"] = base64.b64encode(
+                    json.dumps(cluster_consul_config["auth_info"]).encode("utf-8")
+                )
+                cluster_config = cluster_consul_config["cluster_config"]
+                # 添加证书相关处理
+                if cluster_config["raw_ssl_certificate_authorities"]:
+                    cluster_consul_config["cluster_config"]["raw_ssl_certificate_authorities"] = base64.b64encode(
+                        cluster_config["raw_ssl_certificate_authorities"].encode("utf-8")
+                    )
+                if cluster_config["raw_ssl_certificate"]:
+                    cluster_consul_config["cluster_config"]["raw_ssl_certificate"] = base64.b64encode(
+                        cluster_config["raw_ssl_certificate"].encode("utf-8")
+                    )
+                if cluster_config["raw_ssl_certificate_key"]:
+                    cluster_consul_config["cluster_config"]["raw_ssl_certificate_key"] = base64.b64encode(
+                        cluster_config["raw_ssl_certificate_key"].encode("utf-8")
+                    )
+
+            result_list.append(cluster_consul_config)
+
+        return result_list
diff --git a/bkmonitor/metadata/resources/resources.py b/bkmonitor/metadata/resources/resources.py
index e0edd1246e..a9c1af7a6d 100644
--- a/bkmonitor/metadata/resources/resources.py
+++ b/bkmonitor/metadata/resources/resources.py
@@ -54,10 +54,10 @@
 )
 from metadata.models.constants import (
     DT_TIME_STAMP_NANO,
+    EPOCH_MILLIS_FORMAT,
     NANO_FORMAT,
-    DataIdCreatedFromSystem,
     STRICT_NANO_ES_FORMAT,
-    EPOCH_MILLIS_FORMAT,
+    DataIdCreatedFromSystem,
 )
 from metadata.models.data_link.utils import (
     get_bkbase_raw_data_name_for_v3_datalink,
@@ -938,186 +938,6 @@ def perform_request(self, validated_request_data):
         return result
 
 
-class CreateClusterInfoResource(Resource):
-    """创建存储集群资源"""
-
-    class RequestSerializer(serializers.Serializer):
-        bk_tenant_id = TenantIdField(label="租户ID")
-        cluster_name = serializers.CharField(required=True, label="集群名")
-        cluster_type = serializers.CharField(required=True, label="集群类型")
-        domain_name = serializers.CharField(required=True, label="集群域名")
-        port = serializers.IntegerField(required=True, label="集群端口")
-        description = serializers.CharField(required=False, label="集群描述数据", default="", allow_blank=True)
-        auth_info = serializers.JSONField(required=False, label="身份认证信息", default={})
-        version = serializers.CharField(required=False, label="版本信息", default="")
-        custom_option = serializers.CharField(required=False, label="自定义标签", default="")
-        schema = serializers.CharField(required=False, label="链接协议", default="")
-        is_ssl_verify = serializers.BooleanField(required=False, label="是否需要SSL验证", default=False)
-        ssl_verification_mode = serializers.CharField(required=False, label="校验模式", default="")
-        ssl_certificate_authorities = serializers.CharField(required=False, label="CA 证书内容", default="")
-        ssl_certificate = serializers.CharField(required=False, label="SSL/TLS 证书内容", default="")
-        ssl_certificate_key = serializers.CharField(required=False, label="SSL/TLS 私钥内容", default="")
-        ssl_insecure_skip_verify = serializers.BooleanField(required=False, label="是否跳过服务端校验", default=False)
-        extranet_domain_name = serializers.CharField(required=False, label="外网集群域名", default="")
-        extranet_port = serializers.IntegerField(required=False, label="外网集群端口", default=0)
-        operator = serializers.CharField(required=True, label="操作者")
-
-    def perform_request(self, validated_request_data):
-        # 获取请求来源系统
-        request = get_request()
-        bk_app_code = get_app_code_by_request(request)
-        validated_request_data["registered_system"] = bk_app_code
-
-        # 获取配置的用户名和密码
-        auth_info = validated_request_data.pop("auth_info", {})
-        # NOTE: 因为模型中字段没有设置允许为 null，所以不能赋值 None
-        validated_request_data["username"] = auth_info.get("username", "")
-        validated_request_data["password"] = auth_info.get("password", "")
-
-        cluster = models.ClusterInfo.create_cluster(**validated_request_data)
-        return cluster.cluster_id
-
-
-class ModifyClusterInfoResource(Resource):
-    """修改存储集群信息"""
-
-    class RequestSerializer(serializers.Serializer):
-        bk_tenant_id = TenantIdField(label="租户ID")
-        cluster_id = serializers.IntegerField(required=False, label="存储集群ID", default=None)
-        cluster_name = serializers.CharField(required=False, label="存储集群名", default=None)
-        description = serializers.CharField(required=False, label="存储集群描述", default=None, allow_blank=True)
-        auth_info = serializers.JSONField(required=False, label="身份认证信息", default={})
-        custom_option = serializers.CharField(required=False, label="集群自定义标签", default=None)
-        schema = serializers.CharField(required=False, label="集群链接协议", default=None)
-        is_ssl_verify = serializers.BooleanField(required=False, label="是否需要强制SSL/TLS认证", default=None)
-        ssl_verification_mode = serializers.CharField(required=False, label="校验模式", default=None)
-        ssl_certificate_authorities = serializers.CharField(required=False, label="CA 证书内容", default=None)
-        ssl_certificate = serializers.CharField(required=False, label="SSL/TLS 证书内容", default=None)
-        ssl_certificate_key = serializers.CharField(required=False, label="SSL/TLS 私钥内容", default=None)
-        ssl_insecure_skip_verify = serializers.BooleanField(required=False, label="是否跳过服务端校验", default=None)
-        extranet_domain_name = serializers.CharField(required=False, label="外网集群域名", default=None)
-        extranet_port = serializers.IntegerField(required=False, label="外网集群端口", default=None)
-        operator = serializers.CharField(required=True, label="操作者")
-
-    def perform_request(self, validated_request_data):
-        request = get_request()
-        bk_app_code = get_app_code_by_request(request)
-        bk_tenant_id = validated_request_data.pop("bk_tenant_id")
-
-        # 1. 判断是否存在cluster_id或者cluster_name
-        cluster_id = validated_request_data.pop("cluster_id")
-        cluster_name = validated_request_data.pop("cluster_name")
-
-        if cluster_id is None and cluster_name is None:
-            raise ValueError(_("需要至少提供集群ID或集群名"))
-
-        # 2. 判断是否可以拿到一个唯一的cluster_info
-        query_dict = {"cluster_id": cluster_id} if cluster_id is not None else {"cluster_name": cluster_name}
-        try:
-            cluster_info = models.ClusterInfo.objects.get(
-                bk_tenant_id=bk_tenant_id,
-                registered_system__in=[bk_app_code, models.ClusterInfo.DEFAULT_REGISTERED_SYSTEM],
-                **query_dict,
-            )
-        except models.ClusterInfo.DoesNotExist:
-            raise ValueError(_("找不到指定的集群配置，请确认后重试"))
-
-        # 3. 判断获取是否需要修改用户名和密码
-        auth_info = validated_request_data.pop("auth_info", {})
-        # NOTE: 因为模型中字段没有设置允许为 null，所以不能赋值 None
-        validated_request_data["username"] = auth_info.get("username", "")
-        validated_request_data["password"] = auth_info.get("password", "")
-
-        # 4. 触发修改内容
-        cluster_info.modify(**validated_request_data)
-        return cluster_info.consul_config
-
-
-class DeleteClusterInfoResource(Resource):
-    """删除存储集群信息"""
-
-    class RequestSerializer(serializers.Serializer):
-        bk_tenant_id = TenantIdField(label="租户ID")
-        cluster_id = serializers.IntegerField(required=False, label="存储集群ID", default=None)
-        cluster_name = serializers.CharField(required=False, label="存储集群名", default=None)
-
-    def perform_request(self, validated_request_data):
-        request = get_request()
-        bk_app_code = get_app_code_by_request(request)
-
-        #  判断是否存在cluster_id或者cluster_name
-        cluster_id = validated_request_data.pop("cluster_id")
-        cluster_name = validated_request_data.pop("cluster_name")
-
-        if cluster_id is None and cluster_name is None:
-            raise ValueError(_("需要至少提供集群ID或集群名"))
-
-        #  判断是否可以拿到一个唯一的cluster_info
-        query_dict = {"cluster_id": cluster_id} if cluster_id is not None else {"cluster_name": cluster_name}
-        try:
-            cluster_info = models.ClusterInfo.objects.get(
-                bk_tenant_id=validated_request_data["bk_tenant_id"], registered_system=bk_app_code, **query_dict
-            )
-        except models.ClusterInfo.DoesNotExist:
-            raise ValueError(_("找不到指定的集群配置，请确认后重试"))
-
-        cluster_info.delete()
-
-
-class QueryClusterInfoResource(Resource):
-    class RequestSerializer(serializers.Serializer):
-        bk_tenant_id = TenantIdField(label="租户ID")
-        cluster_id = serializers.IntegerField(required=False, label="存储集群ID", default=None)
-        cluster_name = serializers.CharField(required=False, label="存储集群名", default=None)
-        cluster_type = serializers.CharField(required=False, label="存储集群类型", default=None)
-        is_plain_text = serializers.BooleanField(required=False, label="是否需要明文显示登陆信息", default=False)
-
-    def perform_request(self, validated_request_data):
-        query_dict = {}
-        if validated_request_data["cluster_id"] is not None:
-            query_dict = {"cluster_id": validated_request_data["cluster_id"]}
-
-        elif validated_request_data["cluster_name"] is not None:
-            query_dict = {"cluster_name": validated_request_data["cluster_name"]}
-
-        if validated_request_data["cluster_type"] is not None:
-            query_dict["cluster_type"] = validated_request_data["cluster_type"]
-
-        query_result = models.ClusterInfo.objects.filter(
-            bk_tenant_id=validated_request_data["bk_tenant_id"], **query_dict
-        )
-
-        result_list = []
-        is_plain_text = validated_request_data["is_plain_text"]
-
-        for cluster_info in query_result:
-            cluster_consul_config = cluster_info.consul_config
-
-            # 如果不是明文的方式，需要进行base64编码
-            if not is_plain_text:
-                cluster_consul_config["auth_info"] = base64.b64encode(
-                    json.dumps(cluster_consul_config["auth_info"]).encode("utf-8")
-                )
-                cluster_config = cluster_consul_config["cluster_config"]
-                # 添加证书相关处理
-                if cluster_config["raw_ssl_certificate_authorities"]:
-                    cluster_consul_config["cluster_config"]["raw_ssl_certificate_authorities"] = base64.b64encode(
-                        cluster_config["raw_ssl_certificate_authorities"].encode("utf-8")
-                    )
-                if cluster_config["raw_ssl_certificate"]:
-                    cluster_consul_config["cluster_config"]["raw_ssl_certificate"] = base64.b64encode(
-                        cluster_config["raw_ssl_certificate"].encode("utf-8")
-                    )
-                if cluster_config["raw_ssl_certificate_key"]:
-                    cluster_consul_config["cluster_config"]["raw_ssl_certificate_key"] = base64.b64encode(
-                        cluster_config["raw_ssl_certificate_key"].encode("utf-8")
-                    )
-
-            result_list.append(cluster_consul_config)
-
-        return result_list
-
-
 class QueryEventGroupResource(Resource):
     class RequestSerializer(PageSerializer):
         bk_tenant_id = TenantIdField(label="租户ID")
diff --git a/bkmonitor/metadata/task/bkbase.py b/bkmonitor/metadata/task/bkbase.py
index cfb3ca5b03..0350463c33 100644
--- a/bkmonitor/metadata/task/bkbase.py
+++ b/bkmonitor/metadata/task/bkbase.py
@@ -8,6 +8,7 @@
 specific language governing permissions and limitations under the License.
 """
 
+import copy
 import logging
 import re
 import threading
@@ -23,6 +24,7 @@
 from core.drf_resource import api
 from core.prometheus import metrics
 from metadata import models
+from metadata.models.data_link.data_link_configs import ClusterConfig
 from metadata.models.space.constants import SpaceStatus, SpaceTypes
 from metadata.task.constants import BKBASE_V4_KIND_STORAGE_CONFIGS
 from metadata.task.tasks import sync_bkbase_v4_metadata
@@ -227,7 +229,20 @@ def sync_bkbase_cluster_info(bk_tenant_id: str, cluster_list: list, field_mappin
             port = cluster_spec.get(field_mappings["port"])
             username = cluster_spec.get(field_mappings["username"])
             password = cluster_spec.get(field_mappings["password"])
+            namespace = cluster_metadata["namespace"]
+
+            # 同步ClusterConfig
+            cluster_config_data = copy.deepcopy(cluster_data)
+            cluster_config_data.pop("status", None)
+            ClusterConfig.objects.get_or_create(
+                bk_tenant_id=bk_tenant_id,
+                namespace=namespace,
+                name=cluster_name,
+                kind=ClusterConfig.CLUSTER_TYPE_TO_KIND_MAP[cluster_type],
+                defaults={"origin_config": cluster_config_data},
+            )
 
+            # 设置集群配置
             default_settings = {}
             # 如果是VictoriaMetrics集群，需要获取过期时间
             if cluster_type == models.ClusterInfo.TYPE_VM:
@@ -256,6 +271,11 @@ def sync_bkbase_cluster_info(bk_tenant_id: str, cluster_list: list, field_mappin
                             setattr(cluster, field, value)
                             is_updated = True
 
+                    # 如果集群未被标记为已注册到bkbase平台，则标记为已注册
+                    if not cluster.registered_to_bkbase:
+                        cluster.registered_to_bkbase = True
+                        is_updated = True
+
                     # 如果字段有更新，则保存模型
                     if is_updated:
                         logger.info(f"sync_bkbase_cluster_info: updated {cluster_type} cluster: {cluster_name}")
@@ -266,6 +286,7 @@ def sync_bkbase_cluster_info(bk_tenant_id: str, cluster_list: list, field_mappin
                         bk_tenant_id=bk_tenant_id,
                         cluster_type=cluster_type,
                         cluster_name=cluster_name,
+                        display_name=cluster_name,
                         domain_name=domain_name,
                         port=port,
                         username=username,
@@ -273,6 +294,7 @@ def sync_bkbase_cluster_info(bk_tenant_id: str, cluster_list: list, field_mappin
                         is_default_cluster=False,
                         default_settings=default_settings,
                         registered_system=models.ClusterInfo.BKDATA_REGISTERED_SYSTEM,
+                        registered_to_bkbase=True,
                     )
                     logger.info(f"sync_bkbase_cluster_info: created new {cluster_type} cluster: {cluster_name}")
         except Exception as e:
