# Generated by Django 3.2.25 on 2025-12-09 03:57

from collections import defaultdict

from django.db import migrations, models


def migrate_custom_ts_field_to_time_series(apps, schema_editor):
    """将数据从 CustomTSField 迁移到 TimeSeriesMetric 和 TimeSeriesScope"""

    # 获取模型
    CustomTSTable = apps.get_model("monitor_web", "CustomTSTable")
    CustomTSField = apps.get_model("monitor_web", "CustomTSField")

    # 统计信息
    stats = {
        "total_groups": 0,
        "skipped_groups": 0,
        "processed_groups": 0,
        "scopes_created": 0,
        "scopes_updated": 0,
        "metrics_created": 0,
        "metrics_updated": 0,
    }

    # 从 CustomTSTable 获取所有 (bk_tenant_id, time_series_group_id) 组合
    ts_tables = CustomTSTable.objects.values("bk_tenant_id", "time_series_group_id", "table_id").distinct()
    stats["total_groups"] = ts_tables.count()

    print(f"找到 {stats['total_groups']} 个 CustomTSTable")

    # 提前一次性获取所有 CustomTSField 到内存中
    all_custom_fields = list(CustomTSField.objects.all().order_by("id"))
    fields_by_group = defaultdict(list)
    for field in all_custom_fields:
        fields_by_group[field.time_series_group_id].append(field)

    for ts_table in ts_tables:
        bk_tenant_id = ts_table["bk_tenant_id"]
        group_id = ts_table["time_series_group_id"]
        table_id = ts_table["table_id"]

        try:
            custom_fields = fields_by_group.get(group_id, [])
            if not custom_fields:
                stats["skipped_groups"] += 1
                continue

            metric_fields = [f for f in custom_fields if f.type == CustomTSField.MetricType.METRIC]
            dimension_fields = [f for f in custom_fields if f.type == CustomTSField.MetricType.DIMENSION]

            stats["processed_groups"] += 1

            # 迁移 Scope 和 Metric
            scope_name_to_id = migrate_scope(
                apps, bk_tenant_id, dimension_fields, group_id, metric_fields, table_id, stats
            )
            migrate_metric(apps, group_id, metric_fields, scope_name_to_id, table_id, stats)

        except Exception as e:
            print(f"✗ Group {group_id} 失败: {str(e)}")
            stats["skipped_groups"] += 1

    print(
        f"组: {stats['processed_groups']}/{stats['total_groups']} "
        f"(跳过: {stats['skipped_groups']})\n"
        f"Scope: 新建 {stats['scopes_created']}, 更新 {stats['scopes_updated']}\n"
        f"Metric: 新建 {stats['metrics_created']}, 更新 {stats['metrics_updated']}"
    )


def migrate_scope(apps, bk_tenant_id, dimension_fields, group_id, metric_fields, table_id, stats):
    """迁移 Scope 数据"""
    TimeSeriesScope = apps.get_model("metadata", "TimeSeriesScope")
    TimeSeriesMetric = apps.get_model("metadata", "TimeSeriesMetric")
    ResultTableField = apps.get_model("metadata", "ResultTableField")

    # 收集所有配置信息到统一的数据结构
    scope_info = defaultdict(lambda: {"is_default": False, "dim_configs": {}})

    # 收集所有需要查询的维度名称
    dim_field_dict = {dim_field.name: dim_field for dim_field in dimension_fields}
    all_needed_dimension_names = set(dim_field_dict.keys()) | {
        dim for field in metric_fields for dim in field.config.get("dimensions", [])
    }

    rt_fields_dict = {
        item["field_name"]: item["description"]
        for item in ResultTableField.objects.filter(
            table_id=table_id, field_name__in=all_needed_dimension_names, bk_tenant_id=bk_tenant_id
        ).values("field_name", "description")
    }

    # 收集所有维度的配置信息
    dim_configs = {}
    for dim_name in all_needed_dimension_names:
        config = {}
        # 如果维度在 dim_field_dict 中，提取其配置
        if dim_name in dim_field_dict:
            config = {k: v for k, v in dim_field_dict[dim_name].config.items() if k in ["common", "hidden"]}
        # 添加 alias
        if description := rt_fields_dict.get(dim_name):
            config["alias"] = description

        dim_configs[dim_name] = config

    # 收集 scope 信息和维度使用情况
    for field in metric_fields:
        scope_name = get_scope_name(field, TimeSeriesMetric.DEFAULT_DATA_SCOPE_NAME)

        scope_info[scope_name]["is_default"] = scope_name == TimeSeriesMetric.DEFAULT_DATA_SCOPE_NAME

        # 获取该指标使用的维度列表，并将维度配置合并进来
        for dim_name in field.config.get("dimensions", []):
            if dim_name in dim_configs:
                scope_info[scope_name]["dim_configs"][dim_name] = dim_configs[dim_name]

    # 根据收集的信息批量创建或更新所有 Scope，并配置维度
    existing_scopes = {
        scope.scope_name: scope
        for scope in TimeSeriesScope.objects.filter(group_id=group_id, scope_name__in=scope_info.keys())
    }

    scopes_to_create = []
    scopes_to_update = []

    for scope_name, info in scope_info.items():
        scope_dim_config = info["dim_configs"]

        if scope_name in existing_scopes:
            # 更新已存在的 scope
            scope_obj = existing_scopes[scope_name]
            merged_dim_config = (scope_obj.dimension_config or {}).copy()

            for dim_name, dim_config in scope_dim_config.items():
                merged_dim_config.setdefault(dim_name, {}).update(dim_config)

            if merged_dim_config != scope_obj.dimension_config:
                scope_obj.dimension_config = merged_dim_config
                scopes_to_update.append(scope_obj)
        else:
            # 创建新的 scope
            scopes_to_create.append(
                TimeSeriesScope(
                    group_id=group_id,
                    scope_name=scope_name,
                    dimension_config=scope_dim_config,
                    auto_rules=[],
                    create_from=TimeSeriesScope.CREATE_FROM_DEFAULT
                    if info["is_default"]
                    else TimeSeriesScope.CREATE_FROM_USER,
                )
            )

    # 批量创建和更新
    if scopes_to_create:
        TimeSeriesScope.objects.bulk_create(scopes_to_create, batch_size=500)
        stats["scopes_created"] += len(scopes_to_create)
    if scopes_to_update:
        TimeSeriesScope.objects.bulk_update(scopes_to_update, ["dimension_config"], batch_size=500)
        stats["scopes_updated"] += len(scopes_to_update)

    return {
        scope.scope_name: scope.id
        for scope in TimeSeriesScope.objects.filter(group_id=group_id, scope_name__in=scope_info.keys())
    }


def migrate_metric(apps, group_id, metric_fields, scope_name_to_id, table_id, stats):
    """迁移 Metric 数据"""
    TimeSeriesMetric = apps.get_model("metadata", "TimeSeriesMetric")

    # 批量查询所有已存在的指标到内存中
    existing_metrics = {
        (metric.field_scope, metric.field_name): metric for metric in TimeSeriesMetric.objects.filter(group_id=group_id)
    }

    # 处理指标字段，创建或更新 Metric
    metrics_to_create = []
    metrics_to_update = []

    for field in metric_fields:
        scope_name = get_scope_name(field, TimeSeriesMetric.DEFAULT_DATA_SCOPE_NAME)
        tag_list = field.config.get("dimensions", [])

        # 构建字段配置
        field_config = {"disabled": field.disabled}
        if field.description:
            field_config["alias"] = field.description

        for key in TimeSeriesMetric.MetricConfigFields:
            if key in field.config:
                field_config[key] = field.config[key]

        scope_id = scope_name_to_id.get(scope_name)
        existing = existing_metrics.get((scope_name, field.name))

        if existing:
            existing.scope_id = scope_id
            existing.field_config = field_config
            existing.create_time = field.create_time
            metrics_to_update.append(existing)
        else:
            metrics_to_create.append(
                TimeSeriesMetric(
                    group_id=group_id,
                    scope_id=scope_id,
                    table_id=table_id,
                    field_scope=scope_name,
                    field_name=field.name,
                    tag_list=tag_list,
                    field_config=field_config,
                    label="",
                    create_time=field.create_time,
                    last_modify_time=field.update_time,
                )
            )

    # 批量保存 Metric
    if metrics_to_create:
        TimeSeriesMetric.objects.bulk_create(metrics_to_create, batch_size=500)
        stats["metrics_created"] += len(metrics_to_create)
    if metrics_to_update:
        TimeSeriesMetric.objects.bulk_update(
            metrics_to_update, ["scope_id", "field_config", "create_time"], batch_size=500
        )
        stats["metrics_updated"] += len(metrics_to_update)


def get_scope_name(field, default_scope):
    """获取字段的 scope 名称"""
    labels = field.config.get("label", [])
    return labels[0] if labels else default_scope


class Migration(migrations.Migration):
    dependencies = [
        ("metadata", "0246_migrate_cluster_name"),
    ]

    operations = [
        migrations.AddField(
            model_name="timeseriesgroup",
            name="metric_group_dimensions",
            field=models.JSONField(default=list, verbose_name="指标分组的维度key配置"),
        ),
        migrations.AddField(
            model_name="timeseriesmetric",
            name="create_time",
            field=models.DateTimeField(auto_now_add=True, null=True, verbose_name="创建时间"),
        ),
        migrations.AddField(
            model_name="timeseriesmetric",
            name="field_config",
            field=models.JSONField(default=dict, verbose_name="字段其他配置"),
        ),
        migrations.AddField(
            model_name="timeseriesmetric",
            name="field_scope",
            field=models.CharField(
                db_collation="utf8_bin", default="default", max_length=255, verbose_name="指标字段数据分组名"
            ),
        ),
        migrations.AddField(
            model_name="timeseriesmetric",
            name="scope_id",
            field=models.IntegerField(blank=True, db_index=True, null=True, verbose_name="时序分组ID"),
        ),
        migrations.AlterField(
            model_name="timeseriesmetric",
            name="field_id",
            field=models.AutoField(primary_key=True, serialize=False, verbose_name="字段ID"),
        ),
        migrations.AlterField(
            model_name="timeseriesmetric",
            name="field_name",
            field=models.CharField(db_collation="utf8_bin", max_length=255, verbose_name="指标字段名称"),
        ),
        migrations.AlterField(
            model_name="timeseriesmetric",
            name="group_id",
            field=models.IntegerField(db_index=True, verbose_name="自定义时序数据源ID"),
        ),
        migrations.AlterUniqueTogether(
            name="timeseriesmetric",
            unique_together={("group_id", "field_scope", "field_name")},
        ),
        migrations.CreateModel(
            name="TimeSeriesScope",
            fields=[
                ("id", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                ("group_id", models.IntegerField(db_index=True, verbose_name="自定义时序数据源ID")),
                ("scope_name", models.CharField(db_collation="utf8_bin", max_length=255, verbose_name="指标分组名")),
                ("dimension_config", models.JSONField(default={}, verbose_name="分组下的维度配置")),
                ("auto_rules", models.JSONField(default=[], verbose_name="自动分组的匹配规则列表")),
                (
                    "create_from",
                    models.CharField(
                        choices=[("data", "数据自动创建"), ("user", "用户手动创建"), ("default", "默认分组")],
                        db_index=True,
                        default="data",
                        max_length=10,
                        verbose_name="创建来源",
                    ),
                ),
                ("last_modify_time", models.DateTimeField(auto_now=True, verbose_name="最后更新时间")),
            ],
            options={
                "verbose_name": "自定义时序数据分组记录",
                "verbose_name_plural": "自定义时序数据分组记录表",
                "unique_together": {("group_id", "scope_name")},
            },
        ),
        migrations.RunPython(migrate_custom_ts_field_to_time_series),
    ]
