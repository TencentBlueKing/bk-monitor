# Generated by Django 3.2.25 on 2025-12-09 03:57

import logging
from collections import defaultdict

from django.db import migrations, models

logger = logging.getLogger("metadata")

METRIC_TYPE_METRIC = "metric"
METRIC_TYPE_DIMENSION = "dimension"
DEFAULT_DATA_SCOPE_NAME = "default"
METRIC_CONFIG_FIELDS = ["alias", "unit", "hidden", "aggregate_method", "function", "interval", "disabled"]
CREATE_FROM_DEFAULT = "default"
CREATE_FROM_USER = "user"


def migrate_custom_ts_field_to_time_series(apps, schema_editor):
    """将数据从 CustomTSField 迁移到 TimeSeriesMetric 和 TimeSeriesScope"""

    # 获取模型
    CustomTSTable = apps.get_model("monitor_web", "CustomTSTable")
    CustomTSField = apps.get_model("monitor_web", "CustomTSField")
    CustomTSGroupingRule = apps.get_model("monitor_web", "CustomTSGroupingRule")

    # 统计信息
    stats = {
        "total_groups": 0,
        "skipped_groups": 0,
        "processed_groups": 0,
        "scopes_created": 0,
        "scopes_updated": 0,
        "metrics_created": 0,
        "metrics_updated": 0,
    }

    # 从 CustomTSTable 获取所有 (bk_tenant_id, time_series_group_id) 组合
    ts_tables = CustomTSTable.objects.values("bk_tenant_id", "time_series_group_id", "table_id").distinct()
    stats["total_groups"] = ts_tables.count()

    logger.info(f"[迁移开始] 找到 {stats['total_groups']} 个 CustomTSTable")

    # 提前一次性获取所有 CustomTSField 到内存中
    all_custom_fields = list(CustomTSField.objects.all().order_by("id"))
    fields_by_group = defaultdict(list)
    for field in all_custom_fields:
        fields_by_group[field.time_series_group_id].append(field)

    # 提前一次性获取所有 CustomTSGroupingRule 到内存中
    all_grouping_rules = list(CustomTSGroupingRule.objects.all().order_by("id"))
    grouping_rules_by_group = defaultdict(list)
    for rule in all_grouping_rules:
        grouping_rules_by_group[rule.time_series_group_id].append(rule)

    for ts_table in ts_tables:
        bk_tenant_id = ts_table["bk_tenant_id"]
        group_id = ts_table["time_series_group_id"]
        table_id = ts_table["table_id"]

        try:
            custom_fields = fields_by_group.get(group_id, [])
            if not custom_fields:
                logger.warning(f"[跳过] Group {group_id} (table_id={table_id}): 没有找到字段数据")
                stats["skipped_groups"] += 1
                continue

            metric_fields = [f for f in custom_fields if f.type == METRIC_TYPE_METRIC]
            dimension_fields = [f for f in custom_fields if f.type == METRIC_TYPE_DIMENSION]

            logger.info(f"[处理中] Group {group_id} (table_id={table_id})")
            stats["processed_groups"] += 1

            # 获取该 group 的分组规则
            grouping_rules = grouping_rules_by_group.get(group_id, [])

            # 迁移 Scope 和 Metric
            scope_name_to_id = migrate_scope(
                apps, bk_tenant_id, dimension_fields, group_id, metric_fields, table_id, grouping_rules, stats
            )
            migrate_metric(apps, group_id, metric_fields, scope_name_to_id, table_id, stats)

            logger.info(f"[成功] Group {group_id} 迁移完成")

        except Exception as e:
            logger.error(f"[失败] Group {group_id} (table_id={table_id}) 迁移失败: {str(e)}", exc_info=True)
            stats["skipped_groups"] += 1

    summary = (
        f"组: {stats['processed_groups']}/{stats['total_groups']} "
        f"(跳过: {stats['skipped_groups']})\n"
        f"Scope: 新建 {stats['scopes_created']}, 更新 {stats['scopes_updated']}\n"
        f"Metric: 新建 {stats['metrics_created']}, 更新 {stats['metrics_updated']}"
    )
    logger.info(f"[迁移完成] {summary}")


def migrate_scope(apps, bk_tenant_id, dimension_fields, group_id, metric_fields, table_id, grouping_rules, stats):
    """迁移 Scope 数据"""
    TimeSeriesScope = apps.get_model("metadata", "TimeSeriesScope")
    ResultTableField = apps.get_model("metadata", "ResultTableField")

    # 收集所有配置信息到统一的数据结构
    scope_info = defaultdict(lambda: {"is_default": False, "dim_configs": {}, "auto_rules": []})

    # 收集所有需要查询的维度名称
    dim_field_dict = {dim_field.name: dim_field for dim_field in dimension_fields}
    all_needed_dimension_names = set(dim_field_dict.keys()) | {
        dim for field in metric_fields for dim in field.config.get("dimensions", [])
    }

    rt_fields_dict = {
        item["field_name"]: item["description"]
        for item in ResultTableField.objects.filter(table_id=table_id, bk_tenant_id=bk_tenant_id).values(
            "field_name", "description"
        )
    }

    # 收集所有维度的配置信息
    dim_configs = {}
    for dim_name in all_needed_dimension_names:
        config = {}
        # 如果维度在 dim_field_dict 中，提取其配置
        if dim_name in dim_field_dict:
            config = {k: v for k, v in dim_field_dict[dim_name].config.items() if k in ["common", "hidden"]}
        # 添加 alias
        if description := rt_fields_dict.get(dim_name):
            config["alias"] = description
        elif field := dim_field_dict.get(dim_name):
            config["alias"] = field.description

        dim_configs[dim_name] = config

    # 确保默认分组一定会被创建
    scope_info[DEFAULT_DATA_SCOPE_NAME]["is_default"] = True

    # 收集 scope 信息和维度使用情况
    for field in metric_fields:
        scope_name = get_scope_name(field, DEFAULT_DATA_SCOPE_NAME)

        scope_info[scope_name]["is_default"] = scope_name == DEFAULT_DATA_SCOPE_NAME

        # 获取该指标使用的维度列表，并将维度配置合并进来
        for dim_name in field.config.get("dimensions", []):
            if dim_name in dim_configs:
                scope_info[scope_name]["dim_configs"][dim_name] = dim_configs[dim_name]

    # rule.name 对应 scope_name
    for rule in grouping_rules:
        if rule.name in scope_info:
            scope_info[rule.name]["auto_rules"] = rule.auto_rules

    # 批量创建所有 Scope
    scopes_to_create = [
        TimeSeriesScope(
            group_id=group_id,
            scope_name=scope_name,
            dimension_config=info["dim_configs"],
            auto_rules=info["auto_rules"],
            create_from=CREATE_FROM_DEFAULT if info["is_default"] else CREATE_FROM_USER,
        )
        for scope_name, info in scope_info.items()
    ]

    if scopes_to_create:
        TimeSeriesScope.objects.bulk_create(scopes_to_create, batch_size=500)
        stats["scopes_created"] += len(scopes_to_create)

    return {
        scope.scope_name: scope.id
        for scope in TimeSeriesScope.objects.filter(group_id=group_id, scope_name__in=scope_info.keys())
    }


def migrate_metric(apps, group_id, metric_fields, scope_name_to_id, table_id, stats):
    """迁移 Metric 数据"""
    TimeSeriesMetric = apps.get_model("metadata", "TimeSeriesMetric")

    # 批量查询所有已存在的指标到内存中
    existing_metrics = {
        (metric.field_scope, metric.field_name): metric for metric in TimeSeriesMetric.objects.filter(group_id=group_id)
    }

    # 处理指标字段，创建或更新 Metric
    metrics_to_create = []
    metrics_to_update = []

    for field in metric_fields:
        scope_name = get_scope_name(field, DEFAULT_DATA_SCOPE_NAME)
        tag_list = field.config.get("dimensions", [])

        # 构建字段配置
        field_config = {"disabled": field.disabled}
        if field.description:
            field_config["alias"] = field.description

        for key in METRIC_CONFIG_FIELDS:
            if key in field.config:
                field_config[key] = field.config[key]

        scope_id = scope_name_to_id.get(scope_name)
        existing = existing_metrics.get((scope_name, field.name))

        if existing:
            existing.scope_id = scope_id
            existing.field_config = field_config
            existing.field_scope = DEFAULT_DATA_SCOPE_NAME
            metrics_to_update.append(existing)
        else:
            metrics_to_create.append(
                TimeSeriesMetric(
                    group_id=group_id,
                    scope_id=scope_id,
                    table_id=table_id,
                    field_scope=DEFAULT_DATA_SCOPE_NAME,
                    field_name=field.name,
                    tag_list=tag_list,
                    field_config=field_config,
                    label="",
                    create_time=field.create_time,
                    last_modify_time=field.update_time,
                )
            )

    # 批量保存 Metric
    if metrics_to_create:
        TimeSeriesMetric.objects.bulk_create(metrics_to_create, batch_size=500)
        stats["metrics_created"] += len(metrics_to_create)
    if metrics_to_update:
        TimeSeriesMetric.objects.bulk_update(
            metrics_to_update, ["scope_id", "field_config", "field_scope"], batch_size=500
        )
        stats["metrics_updated"] += len(metrics_to_update)


def get_scope_name(field, default_scope):
    """获取字段的 scope 名称"""
    labels = field.config.get("label", [])
    return labels[0] if labels else default_scope


class Migration(migrations.Migration):
    dependencies = [
        ("metadata", "0248_auto_20260119_0334"),
    ]

    operations = [
        migrations.AddField(
            model_name="timeseriesgroup",
            name="metric_group_dimensions",
            field=models.JSONField(default=list, verbose_name="指标分组的维度key配置"),
        ),
        migrations.AddField(
            model_name="timeseriesmetric",
            name="create_time",
            field=models.DateTimeField(auto_now_add=True, null=True, verbose_name="创建时间"),
        ),
        migrations.AddField(
            model_name="timeseriesmetric",
            name="field_config",
            field=models.JSONField(default=dict, verbose_name="字段其他配置"),
        ),
        migrations.AddField(
            model_name="timeseriesmetric",
            name="field_scope",
            field=models.CharField(
                db_collation="utf8_bin", default="default", max_length=255, verbose_name="指标字段数据分组名"
            ),
        ),
        migrations.AddField(
            model_name="timeseriesmetric",
            name="scope_id",
            field=models.IntegerField(blank=True, db_index=True, null=True, verbose_name="时序分组ID"),
        ),
        migrations.AlterField(
            model_name="timeseriesmetric",
            name="field_id",
            field=models.AutoField(primary_key=True, serialize=False, verbose_name="字段ID"),
        ),
        migrations.AlterField(
            model_name="timeseriesmetric",
            name="field_name",
            field=models.CharField(db_collation="utf8_bin", max_length=255, verbose_name="指标字段名称"),
        ),
        migrations.AlterField(
            model_name="timeseriesmetric",
            name="group_id",
            field=models.IntegerField(db_index=True, verbose_name="自定义时序数据源ID"),
        ),
        migrations.AlterUniqueTogether(
            name="timeseriesmetric",
            unique_together={("group_id", "field_scope", "field_name")},
        ),
        migrations.CreateModel(
            name="TimeSeriesScope",
            fields=[
                ("id", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                ("group_id", models.IntegerField(db_index=True, verbose_name="自定义时序数据源ID")),
                ("scope_name", models.CharField(db_collation="utf8_bin", max_length=255, verbose_name="指标分组名")),
                ("dimension_config", models.JSONField(default={}, verbose_name="分组下的维度配置")),
                ("auto_rules", models.JSONField(default=[], verbose_name="自动分组的匹配规则列表")),
                (
                    "create_from",
                    models.CharField(
                        choices=[("data", "数据自动创建"), ("user", "用户手动创建"), ("default", "默认分组")],
                        db_index=True,
                        default="data",
                        max_length=10,
                        verbose_name="创建来源",
                    ),
                ),
                ("last_modify_time", models.DateTimeField(auto_now=True, verbose_name="最后更新时间")),
            ],
            options={
                "verbose_name": "自定义时序数据分组记录",
                "verbose_name_plural": "自定义时序数据分组记录表",
                "unique_together": {("group_id", "scope_name")},
            },
        ),
        migrations.RunPython(migrate_custom_ts_field_to_time_series),
    ]
